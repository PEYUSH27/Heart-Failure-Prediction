# -*- coding: utf-8 -*-
"""Untitled37.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i3It_2c7kLs6XO4q9gaAikj4HI8b92RP
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import (
    confusion_matrix, accuracy_score, precision_score, recall_score,
    f1_score, classification_report, roc_auc_score, roc_curve
)
import warnings
warnings.filterwarnings("ignore")

df = pd.read_csv('/content/heart.csv')
print("Data shape:", df.shape)
df.head()

print("\nMissing values per column:")
print(df.isnull().sum())

print("\nDataset info:")
df.info()

for col in df.columns:
    if df[col].dtype == 'object':
        le = LabelEncoder()
        df[col] = le.fit_transform(df[col])
        print(f"Encoded column: {col}")

plt.figure(figsize=(10,8))
sns.heatmap(df.corr(), annot=True, cmap='coolwarm')
plt.title("Correlation Heatmap of Heart Dataset")
plt.show()

# Step 6: Define features (X) and target (y)
# Automatically handle if 'target' column not found
if 'target' in df.columns:
    X = df.drop('target', axis=1)
    y = df['target']
else:
    # fallback: use last column as target
    target_col = df.columns[-1]
    print(f"⚠️ 'target' column not found, using '{target_col}' as target.")
    X = df.drop(target_col, axis=1)
    y = df[target_col]

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

rf = RandomForestClassifier(n_estimators=200, random_state=42)
rf.fit(X_train, y_train)

y_pred = rf.predict(X_test)
y_proba = None
try:
    # try to get probability for positive class (works for binary or multi-class)
    y_proba = rf.predict_proba(X_test)
except Exception:
    y_proba = None

acc = accuracy_score(y_test, y_pred)
prec = precision_score(y_test, y_pred, average='binary' if len(np.unique(y))==2 else 'weighted', zero_division=0)
rec = recall_score(y_test, y_pred, average='binary' if len(np.unique(y))==2 else 'weighted', zero_division=0)
f1 = f1_score(y_test, y_pred, average='binary' if len(np.unique(y))==2 else 'weighted', zero_division=0)

print("\n--- Model Evaluation ---")
print(f"Accuracy:  {acc:.4f}")
print(f"Precision: {prec:.4f}")
print(f"Recall:    {rec:.4f}")
print(f"F1-score:  {f1:.4f}")
print("\nClassification Report:\n")
print(classification_report(y_test, y_pred, zero_division=0))

# ROC-AUC (only for binary or if you choose a class vs rest)
if y_proba is not None and len(np.unique(y)) == 2:
    # positive class index assumed to be 1
    try:
        auc = roc_auc_score(y_test, y_proba[:, 1])
        fpr, tpr, _ = roc_curve(y_test, y_proba[:, 1])
        print(f"ROC AUC:   {auc:.4f}")
        plt.figure(figsize=(6,5))
        plt.plot(fpr, tpr, label=f'ROC curve (AUC = {auc:.3f})')
        plt.plot([0,1],[0,1],'--')
        plt.xlabel('False Positive Rate')
        plt.ylabel('True Positive Rate')
        plt.title('ROC Curve')
        plt.legend()
        plt.show()
    except Exception as e:
        print("Could not compute ROC-AUC:", e)
elif y_proba is not None:
    print("ROC-AUC skipped (multi-class).")

cm = confusion_matrix(y_test, y_pred)
print("Confusion Matrix:\n", cm)

# Plot it
plt.figure(figsize=(5,4))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', cbar=False,
            xticklabels=['Predicted 0', 'Predicted 1'],
            yticklabels=['Actual 0', 'Actual 1'])
plt.title('Confusion Matrix')
plt.xlabel('Predicted Label')
plt.ylabel('Actual Label')
plt.show()

importances = rf.feature_importances_
feat_names = X.columns
fi = pd.Series(importances, index=feat_names).sort_values(ascending=False)
plt.figure(figsize=(10,6))
sns.barplot(x=fi.values[:25], y=fi.index[:25])   # top 25 features (or fewer)
plt.title('Feature Importance (top 25)')
plt.xlabel('Importance')
plt.ylabel('Feature')
plt.show()

print("\nTop features:")
print(fi.head(15))

out = X_test.copy()
out['y_true'] = y_test
out['y_pred'] = y_pred
if y_proba is not None and y_proba.shape[1] == 2:
    out['y_proba_pos'] = y_proba[:,1]
out.to_csv('/content/heart_rf_predictions.csv', index=False)
print("\nSaved predictions to '/content/heart_rf_predictions.csv'")